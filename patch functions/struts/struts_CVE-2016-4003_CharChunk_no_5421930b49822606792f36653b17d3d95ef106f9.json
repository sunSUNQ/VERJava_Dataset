[{"cve_id": "struts", "added_line": [{"target_line_num": 2, "target_line_code": "/*"}, {"target_line_num": 3, "target_line_code": "*  Licensed to the Apache Software Foundation (ASF) under one or more"}, {"target_line_num": 4, "target_line_code": "*  contributor license agreements.  See the NOTICE file distributed with"}, {"target_line_num": 5, "target_line_code": "*  this work for additional information regarding copyright ownership."}, {"target_line_num": 6, "target_line_code": "*  The ASF licenses this file to You under the Apache License, Version 2.0"}, {"target_line_num": 7, "target_line_code": "*  (the \"License\"); you may not use this file except in compliance with"}, {"target_line_num": 8, "target_line_code": "*  the License.  You may obtain a copy of the License at"}, {"target_line_num": 9, "target_line_code": "*"}, {"target_line_num": 11, "target_line_code": "*"}, {"target_line_num": 12, "target_line_code": "*  Unless required by applicable law or agreed to in writing, software"}, {"target_line_num": 13, "target_line_code": "*  distributed under the License is distributed on an \"AS IS\" BASIS,"}, {"target_line_num": 14, "target_line_code": "*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."}, {"target_line_num": 15, "target_line_code": "*  See the License for the specific language governing permissions and"}, {"target_line_num": 16, "target_line_code": "*  limitations under the License."}, {"target_line_num": 17, "target_line_code": "*/"}, {"target_line_num": 18, "target_line_code": "package org.apache.struts2.util.tomcat.buf;"}, {"target_line_num": 20, "target_line_code": "import java.io.IOException;"}, {"target_line_num": 21, "target_line_code": "import java.io.Serializable;"}, {"target_line_num": 23, "target_line_code": "/**"}, {"target_line_num": 24, "target_line_code": "* Utilities to manipulate char chunks. While String is"}, {"target_line_num": 25, "target_line_code": "* the easiest way to manipulate chars ( search, substrings, etc),"}, {"target_line_num": 26, "target_line_code": "* it is known to not be the most efficient solution - Strings are"}, {"target_line_num": 27, "target_line_code": "* designed as immutable and secure objects."}, {"target_line_num": 28, "target_line_code": "*"}, {"target_line_num": 29, "target_line_code": "* @author dac@sun.com"}, {"target_line_num": 30, "target_line_code": "* @author James Todd [gonzo@sun.com]"}, {"target_line_num": 31, "target_line_code": "* @author Costin Manolache"}, {"target_line_num": 32, "target_line_code": "* @author Remy Maucherat"}, {"target_line_num": 33, "target_line_code": "*/"}, {"target_line_num": 34, "target_line_code": "public final class CharChunk implements Cloneable, Serializable, CharSequence {"}, {"target_line_num": 36, "target_line_code": "private static final long serialVersionUID = 1L;"}, {"target_line_num": 39, "target_line_code": "public static interface CharInputChannel {"}, {"target_line_num": 40, "target_line_code": "/**"}, {"target_line_num": 41, "target_line_code": "* Read new bytes ( usually the internal conversion buffer )."}, {"target_line_num": 42, "target_line_code": "* The implementation is allowed to ignore the parameters,"}, {"target_line_num": 43, "target_line_code": "* and mutate the chunk if it wishes to implement its own buffering."}, {"target_line_num": 44, "target_line_code": "*/"}, {"target_line_num": 45, "target_line_code": "public int realReadChars(char cbuf[], int off, int len)"}, {"target_line_num": 46, "target_line_code": "throws IOException;"}, {"target_line_num": 48, "target_line_code": "/**"}, {"target_line_num": 49, "target_line_code": "*  When we need more space we'll either"}, {"target_line_num": 50, "target_line_code": "*  grow the buffer ( up to the limit ) or send it to a channel."}, {"target_line_num": 51, "target_line_code": "*/"}, {"target_line_num": 52, "target_line_code": "public static interface CharOutputChannel {"}, {"target_line_num": 53, "target_line_code": "/** Send the bytes ( usually the internal conversion buffer )."}, {"target_line_num": 54, "target_line_code": "*  Expect 8k output if the buffer is full."}, {"target_line_num": 55, "target_line_code": "*/"}, {"target_line_num": 56, "target_line_code": "public void realWriteChars(char cbuf[], int off, int len)"}, {"target_line_num": 57, "target_line_code": "throws IOException;"}, {"target_line_num": 62, "target_line_code": "private int hashCode = 0;"}, {"target_line_num": 64, "target_line_code": "private boolean hasHashCode = false;"}, {"target_line_num": 67, "target_line_code": "private char buff[];"}, {"target_line_num": 69, "target_line_code": "private int start;"}, {"target_line_num": 70, "target_line_code": "private int end;"}, {"target_line_num": 76, "target_line_code": "private int limit=-1;"}, {"target_line_num": 78, "target_line_code": "private CharInputChannel in = null;"}, {"target_line_num": 79, "target_line_code": "private CharOutputChannel out = null;"}, {"target_line_num": 81, "target_line_code": "private boolean optimizedWrite=true;"}, {"target_line_num": 83, "target_line_code": "/**"}, {"target_line_num": 84, "target_line_code": "* Creates a new, uninitialized CharChunk object."}, {"target_line_num": 85, "target_line_code": "*/"}, {"target_line_num": 86, "target_line_code": "public CharChunk() {"}, {"target_line_num": 89, "target_line_code": "public CharChunk(int size) {"}, {"target_line_num": 90, "target_line_code": "allocate( size, -1 );"}, {"target_line_num": 95, "target_line_code": "public boolean isNull() {"}, {"target_line_num": 96, "target_line_code": "if( end > 0 ) {"}, {"target_line_num": 97, "target_line_code": "return false;"}, {"target_line_num": 102, "target_line_code": "/**"}, {"target_line_num": 103, "target_line_code": "* Resets the message bytes to an uninitialized state."}, {"target_line_num": 104, "target_line_code": "*/"}, {"target_line_num": 105, "target_line_code": "public void recycle() {"}, {"target_line_num": 108, "target_line_code": "hasHashCode = false;"}, {"target_line_num": 109, "target_line_code": "start=0;"}, {"target_line_num": 110, "target_line_code": "end=0;"}, {"target_line_num": 115, "target_line_code": "public void allocate( int initial, int limit  ) {"}, {"target_line_num": 116, "target_line_code": "if( buff==null || buff.length < initial ) {"}, {"target_line_num": 117, "target_line_code": "buff=new char[initial];"}, {"target_line_num": 119, "target_line_code": "this.limit=limit;"}, {"target_line_num": 120, "target_line_code": "start=0;"}, {"target_line_num": 121, "target_line_code": "end=0;"}, {"target_line_num": 122, "target_line_code": "isSet=true;"}, {"target_line_num": 123, "target_line_code": "hasHashCode = false;"}, {"target_line_num": 127, "target_line_code": "public void setOptimizedWrite(boolean optimizedWrite) {"}, {"target_line_num": 128, "target_line_code": "this.optimizedWrite = optimizedWrite;"}, {"target_line_num": 131, "target_line_code": "public void setChars( char[] c, int off, int len ) {"}, {"target_line_num": 132, "target_line_code": "buff=c;"}, {"target_line_num": 133, "target_line_code": "start=off;"}, {"target_line_num": 134, "target_line_code": "end=start + len;"}, {"target_line_num": 135, "target_line_code": "isSet=true;"}, {"target_line_num": 136, "target_line_code": "hasHashCode = false;"}, {"target_line_num": 139, "target_line_code": "/** Maximum amount of data in this buffer."}, {"target_line_num": 140, "target_line_code": "*"}, {"target_line_num": 141, "target_line_code": "*  If -1 or not set, the buffer will grow indefinitely."}, {"target_line_num": 142, "target_line_code": "*  Can be smaller than the current buffer size ( which will not shrink )."}, {"target_line_num": 143, "target_line_code": "*  When the limit is reached, the buffer will be flushed ( if out is set )"}, {"target_line_num": 144, "target_line_code": "*  or throw exception."}, {"target_line_num": 145, "target_line_code": "*/"}, {"target_line_num": 146, "target_line_code": "public void setLimit(int limit) {"}, {"target_line_num": 147, "target_line_code": "this.limit=limit;"}, {"target_line_num": 150, "target_line_code": "public int getLimit() {"}, {"target_line_num": 151, "target_line_code": "return limit;"}, {"target_line_num": 154, "target_line_code": "/**"}, {"target_line_num": 155, "target_line_code": "* When the buffer is empty, read the data from the input channel."}, {"target_line_num": 156, "target_line_code": "*/"}, {"target_line_num": 157, "target_line_code": "public void setCharInputChannel(CharInputChannel in) {"}, {"target_line_num": 158, "target_line_code": "this.in = in;"}, {"target_line_num": 161, "target_line_code": "/** When the buffer is full, write the data to the output channel."}, {"target_line_num": 162, "target_line_code": "*         Also used when large amount of data is appended."}, {"target_line_num": 163, "target_line_code": "*"}, {"target_line_num": 164, "target_line_code": "*  If not set, the buffer will grow to the limit."}, {"target_line_num": 165, "target_line_code": "*/"}, {"target_line_num": 166, "target_line_code": "public void setCharOutputChannel(CharOutputChannel out) {"}, {"target_line_num": 167, "target_line_code": "this.out=out;"}, {"target_line_num": 171, "target_line_code": "public char[] getChars()"}, {"target_line_num": 172, "target_line_code": "{"}, {"target_line_num": 173, "target_line_code": "return getBuffer();"}, {"target_line_num": 176, "target_line_code": "public char[] getBuffer()"}, {"target_line_num": 177, "target_line_code": "{"}, {"target_line_num": 178, "target_line_code": "return buff;"}, {"target_line_num": 181, "target_line_code": "/**"}, {"target_line_num": 182, "target_line_code": "* Returns the start offset of the bytes."}, {"target_line_num": 183, "target_line_code": "* For output this is the end of the buffer."}, {"target_line_num": 184, "target_line_code": "*/"}, {"target_line_num": 185, "target_line_code": "public int getStart() {"}, {"target_line_num": 186, "target_line_code": "return start;"}, {"target_line_num": 189, "target_line_code": "public int getOffset() {"}, {"target_line_num": 190, "target_line_code": "return start;"}, {"target_line_num": 193, "target_line_code": "/**"}, {"target_line_num": 194, "target_line_code": "* Returns the start offset of the bytes."}, {"target_line_num": 195, "target_line_code": "*/"}, {"target_line_num": 196, "target_line_code": "public void setOffset(int off) {"}, {"target_line_num": 197, "target_line_code": "start=off;"}, {"target_line_num": 200, "target_line_code": "/**"}, {"target_line_num": 201, "target_line_code": "* Returns the length of the bytes."}, {"target_line_num": 202, "target_line_code": "*/"}, {"target_line_num": 203, "target_line_code": "public int getLength() {"}, {"target_line_num": 204, "target_line_code": "return end-start;"}, {"target_line_num": 208, "target_line_code": "public int getEnd() {"}, {"target_line_num": 209, "target_line_code": "return end;"}, {"target_line_num": 212, "target_line_code": "public void setEnd( int i ) {"}, {"target_line_num": 213, "target_line_code": "end=i;"}, {"target_line_num": 218, "target_line_code": "public void append( char b )"}, {"target_line_num": 219, "target_line_code": "throws IOException"}, {"target_line_num": 220, "target_line_code": "{"}, {"target_line_num": 221, "target_line_code": "makeSpace( 1 );"}, {"target_line_num": 224, "target_line_code": "if( limit >0 && end >= limit ) {"}, {"target_line_num": 225, "target_line_code": "flushBuffer();"}, {"target_line_num": 227, "target_line_code": "buff[end++]=b;"}, {"target_line_num": 230, "target_line_code": "public void append( CharChunk src )"}, {"target_line_num": 231, "target_line_code": "throws IOException"}, {"target_line_num": 232, "target_line_code": "{"}, {"target_line_num": 233, "target_line_code": "append( src.getBuffer(), src.getOffset(), src.getLength());"}, {"target_line_num": 236, "target_line_code": "/** Add data to the buffer"}, {"target_line_num": 237, "target_line_code": "*/"}, {"target_line_num": 238, "target_line_code": "public void append( char src[], int off, int len )"}, {"target_line_num": 239, "target_line_code": "throws IOException"}, {"target_line_num": 240, "target_line_code": "{"}, {"target_line_num": 242, "target_line_code": "makeSpace( len );"}, {"target_line_num": 245, "target_line_code": "if( limit < 0 ) {"}, {"target_line_num": 247, "target_line_code": "System.arraycopy( src, off, buff, end, len );"}, {"target_line_num": 248, "target_line_code": "end+=len;"}, {"target_line_num": 249, "target_line_code": "return;"}, {"target_line_num": 255, "target_line_code": "if ( optimizedWrite && len == limit && end == start && out != null ) {"}, {"target_line_num": 256, "target_line_code": "out.realWriteChars( src, off, len );"}, {"target_line_num": 257, "target_line_code": "return;"}, {"target_line_num": 261, "target_line_code": "if( len <= limit - end ) {"}, {"target_line_num": 264, "target_line_code": "System.arraycopy( src, off, buff, end, len );"}, {"target_line_num": 266, "target_line_code": "end+=len;"}, {"target_line_num": 267, "target_line_code": "return;"}, {"target_line_num": 282, "target_line_code": "if( len + end < 2 * limit ) {"}, {"target_line_num": 283, "target_line_code": "/* If the request length exceeds the size of the output buffer,"}, {"target_line_num": 284, "target_line_code": "flush the output buffer and then write the data directly."}, {"target_line_num": 285, "target_line_code": "We can't avoid 2 writes, but we can write more on the second"}, {"target_line_num": 286, "target_line_code": "*/"}, {"target_line_num": 287, "target_line_code": "int avail=limit-end;"}, {"target_line_num": 288, "target_line_code": "System.arraycopy(src, off, buff, end, avail);"}, {"target_line_num": 289, "target_line_code": "end += avail;"}, {"target_line_num": 291, "target_line_code": "flushBuffer();"}, {"target_line_num": 293, "target_line_code": "System.arraycopy(src, off+avail, buff, end, len - avail);"}, {"target_line_num": 294, "target_line_code": "end+= len - avail;"}, {"target_line_num": 299, "target_line_code": "flushBuffer();"}, {"target_line_num": 301, "target_line_code": "out.realWriteChars( src, off, len );"}, {"target_line_num": 306, "target_line_code": "/** Append a string to the buffer"}, {"target_line_num": 307, "target_line_code": "*/"}, {"target_line_num": 308, "target_line_code": "public void append(String s) throws IOException {"}, {"target_line_num": 309, "target_line_code": "append(s, 0, s.length());"}, {"target_line_num": 312, "target_line_code": "/** Append a string to the buffer"}, {"target_line_num": 313, "target_line_code": "*/"}, {"target_line_num": 314, "target_line_code": "public void append(String s, int off, int len) throws IOException {"}, {"target_line_num": 315, "target_line_code": "if (s==null) {"}, {"target_line_num": 316, "target_line_code": "return;"}, {"target_line_num": 320, "target_line_code": "makeSpace( len );"}, {"target_line_num": 323, "target_line_code": "if( limit < 0 ) {"}, {"target_line_num": 325, "target_line_code": "s.getChars(off, off+len, buff, end );"}, {"target_line_num": 326, "target_line_code": "end+=len;"}, {"target_line_num": 327, "target_line_code": "return;"}, {"target_line_num": 330, "target_line_code": "int sOff = off;"}, {"target_line_num": 331, "target_line_code": "int sEnd = off + len;"}, {"target_line_num": 332, "target_line_code": "while (sOff < sEnd) {"}, {"target_line_num": 333, "target_line_code": "int d = min(limit - end, sEnd - sOff);"}, {"target_line_num": 334, "target_line_code": "s.getChars( sOff, sOff+d, buff, end);"}, {"target_line_num": 335, "target_line_code": "sOff += d;"}, {"target_line_num": 336, "target_line_code": "end += d;"}, {"target_line_num": 337, "target_line_code": "if (end >= limit) {"}, {"target_line_num": 338, "target_line_code": "flushBuffer();"}, {"target_line_num": 345, "target_line_code": "public int substract()"}, {"target_line_num": 346, "target_line_code": "throws IOException {"}, {"target_line_num": 348, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 349, "target_line_code": "if (in == null) {"}, {"target_line_num": 350, "target_line_code": "return -1;"}, {"target_line_num": 352, "target_line_code": "int n = in.realReadChars(buff, end, buff.length - end);"}, {"target_line_num": 353, "target_line_code": "if (n < 0) {"}, {"target_line_num": 354, "target_line_code": "return -1;"}, {"target_line_num": 358, "target_line_code": "return (buff[start++]);"}, {"target_line_num": 362, "target_line_code": "public int substract( char src[], int off, int len )"}, {"target_line_num": 363, "target_line_code": "throws IOException {"}, {"target_line_num": 365, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 366, "target_line_code": "if (in == null) {"}, {"target_line_num": 367, "target_line_code": "return -1;"}, {"target_line_num": 369, "target_line_code": "int n = in.realReadChars( buff, end, buff.length - end);"}, {"target_line_num": 370, "target_line_code": "if (n < 0) {"}, {"target_line_num": 371, "target_line_code": "return -1;"}, {"target_line_num": 375, "target_line_code": "int n = len;"}, {"target_line_num": 376, "target_line_code": "if (len > getLength()) {"}, {"target_line_num": 377, "target_line_code": "n = getLength();"}, {"target_line_num": 379, "target_line_code": "System.arraycopy(buff, start, src, off, n);"}, {"target_line_num": 380, "target_line_code": "start += n;"}, {"target_line_num": 381, "target_line_code": "return n;"}, {"target_line_num": 386, "target_line_code": "public void flushBuffer()"}, {"target_line_num": 387, "target_line_code": "throws IOException"}, {"target_line_num": 388, "target_line_code": "{"}, {"target_line_num": 390, "target_line_code": "if( out==null ) {"}, {"target_line_num": 391, "target_line_code": "throw new IOException( \"Buffer overflow, no sink \" + limit + \" \" +"}, {"target_line_num": 392, "target_line_code": "buff.length  );"}, {"target_line_num": 394, "target_line_code": "out.realWriteChars( buff, start, end - start );"}, {"target_line_num": 395, "target_line_code": "end=start;"}, {"target_line_num": 398, "target_line_code": "/** Make space for len chars. If len is small, allocate"}, {"target_line_num": 399, "target_line_code": "*        a reserve space too. Never grow bigger than limit."}, {"target_line_num": 400, "target_line_code": "*/"}, {"target_line_num": 401, "target_line_code": "public void makeSpace(int count)"}, {"target_line_num": 402, "target_line_code": "{"}, {"target_line_num": 403, "target_line_code": "char[] tmp = null;"}, {"target_line_num": 405, "target_line_code": "int newSize;"}, {"target_line_num": 406, "target_line_code": "int desiredSize=end + count;"}, {"target_line_num": 409, "target_line_code": "if( limit > 0 &&"}, {"target_line_num": 410, "target_line_code": "desiredSize > limit) {"}, {"target_line_num": 411, "target_line_code": "desiredSize=limit;"}, {"target_line_num": 414, "target_line_code": "if( buff==null ) {"}, {"target_line_num": 415, "target_line_code": "if( desiredSize < 256 )"}, {"target_line_num": 416, "target_line_code": "{"}, {"target_line_num": 419, "target_line_code": "buff=new char[desiredSize];"}, {"target_line_num": 424, "target_line_code": "if( desiredSize <= buff.length) {"}, {"target_line_num": 425, "target_line_code": "return;"}, {"target_line_num": 428, "target_line_code": "if( desiredSize < 2 * buff.length ) {"}, {"target_line_num": 429, "target_line_code": "newSize= buff.length * 2;"}, {"target_line_num": 430, "target_line_code": "if( limit >0 &&"}, {"target_line_num": 431, "target_line_code": "newSize > limit ) {"}, {"target_line_num": 432, "target_line_code": "newSize=limit;"}, {"target_line_num": 434, "target_line_code": "tmp=new char[newSize];"}, {"target_line_num": 435, "target_line_code": "} else {"}, {"target_line_num": 436, "target_line_code": "newSize= buff.length * 2 + count ;"}, {"target_line_num": 437, "target_line_code": "if( limit > 0 &&"}, {"target_line_num": 438, "target_line_code": "newSize > limit ) {"}, {"target_line_num": 439, "target_line_code": "newSize=limit;"}, {"target_line_num": 441, "target_line_code": "tmp=new char[newSize];"}, {"target_line_num": 444, "target_line_code": "System.arraycopy(buff, 0, tmp, 0, end);"}, {"target_line_num": 445, "target_line_code": "buff = tmp;"}, {"target_line_num": 446, "target_line_code": "tmp = null;"}, {"target_line_num": 451, "target_line_code": "@Override"}, {"target_line_num": 452, "target_line_code": "public String toString() {"}, {"target_line_num": 453, "target_line_code": "if (null == buff) {"}, {"target_line_num": 454, "target_line_code": "return null;"}, {"target_line_num": 455, "target_line_code": "} else if (end-start == 0) {"}, {"target_line_num": 456, "target_line_code": "return \"\";"}, {"target_line_num": 458, "target_line_code": "return StringCache.toString(this);"}, {"target_line_num": 461, "target_line_code": "public String toStringInternal() {"}, {"target_line_num": 462, "target_line_code": "return new String(buff, start, end-start);"}, {"target_line_num": 467, "target_line_code": "@Override"}, {"target_line_num": 468, "target_line_code": "public boolean equals(Object obj) {"}, {"target_line_num": 469, "target_line_code": "if (obj instanceof CharChunk) {"}, {"target_line_num": 470, "target_line_code": "return equals((CharChunk) obj);"}, {"target_line_num": 472, "target_line_code": "return false;"}, {"target_line_num": 475, "target_line_code": "/**"}, {"target_line_num": 476, "target_line_code": "* Compares the message bytes to the specified String object."}, {"target_line_num": 477, "target_line_code": "* @param s the String to compare"}, {"target_line_num": 478, "target_line_code": "* @return true if the comparison succeeded, false otherwise"}, {"target_line_num": 479, "target_line_code": "*/"}, {"target_line_num": 480, "target_line_code": "public boolean equals(String s) {"}, {"target_line_num": 481, "target_line_code": "char[] c = buff;"}, {"target_line_num": 482, "target_line_code": "int len = end-start;"}, {"target_line_num": 483, "target_line_code": "if (c == null || len != s.length()) {"}, {"target_line_num": 484, "target_line_code": "return false;"}, {"target_line_num": 486, "target_line_code": "int off = start;"}, {"target_line_num": 487, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 488, "target_line_code": "if (c[off++] != s.charAt(i)) {"}, {"target_line_num": 489, "target_line_code": "return false;"}, {"target_line_num": 492, "target_line_code": "return true;"}, {"target_line_num": 495, "target_line_code": "/**"}, {"target_line_num": 496, "target_line_code": "* Compares the message bytes to the specified String object."}, {"target_line_num": 497, "target_line_code": "* @param s the String to compare"}, {"target_line_num": 498, "target_line_code": "* @return true if the comparison succeeded, false otherwise"}, {"target_line_num": 499, "target_line_code": "*/"}, {"target_line_num": 500, "target_line_code": "public boolean equalsIgnoreCase(String s) {"}, {"target_line_num": 501, "target_line_code": "char[] c = buff;"}, {"target_line_num": 502, "target_line_code": "int len = end-start;"}, {"target_line_num": 503, "target_line_code": "if (c == null || len != s.length()) {"}, {"target_line_num": 504, "target_line_code": "return false;"}, {"target_line_num": 506, "target_line_code": "int off = start;"}, {"target_line_num": 507, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 508, "target_line_code": "if (Ascii.toLower( c[off++] ) != Ascii.toLower( s.charAt(i))) {"}, {"target_line_num": 509, "target_line_code": "return false;"}, {"target_line_num": 512, "target_line_code": "return true;"}, {"target_line_num": 515, "target_line_code": "public boolean equals(CharChunk cc) {"}, {"target_line_num": 516, "target_line_code": "return equals( cc.getChars(), cc.getOffset(), cc.getLength());"}, {"target_line_num": 519, "target_line_code": "public boolean equals(char b2[], int off2, int len2) {"}, {"target_line_num": 520, "target_line_code": "char b1[]=buff;"}, {"target_line_num": 521, "target_line_code": "if( b1==null && b2==null ) {"}, {"target_line_num": 522, "target_line_code": "return true;"}, {"target_line_num": 525, "target_line_code": "if (b1== null || b2==null || end-start != len2) {"}, {"target_line_num": 526, "target_line_code": "return false;"}, {"target_line_num": 528, "target_line_code": "int off1 = start;"}, {"target_line_num": 529, "target_line_code": "int len=end-start;"}, {"target_line_num": 530, "target_line_code": "while ( len-- > 0) {"}, {"target_line_num": 531, "target_line_code": "if (b1[off1++] != b2[off2++]) {"}, {"target_line_num": 532, "target_line_code": "return false;"}, {"target_line_num": 535, "target_line_code": "return true;"}, {"target_line_num": 538, "target_line_code": "/**"}, {"target_line_num": 539, "target_line_code": "* Returns true if the message bytes starts with the specified string."}, {"target_line_num": 540, "target_line_code": "* @param s the string"}, {"target_line_num": 541, "target_line_code": "*/"}, {"target_line_num": 542, "target_line_code": "public boolean startsWith(String s) {"}, {"target_line_num": 543, "target_line_code": "char[] c = buff;"}, {"target_line_num": 544, "target_line_code": "int len = s.length();"}, {"target_line_num": 545, "target_line_code": "if (c == null || len > end-start) {"}, {"target_line_num": 546, "target_line_code": "return false;"}, {"target_line_num": 548, "target_line_code": "int off = start;"}, {"target_line_num": 549, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 550, "target_line_code": "if (c[off++] != s.charAt(i)) {"}, {"target_line_num": 551, "target_line_code": "return false;"}, {"target_line_num": 554, "target_line_code": "return true;"}, {"target_line_num": 557, "target_line_code": "/**"}, {"target_line_num": 558, "target_line_code": "* Returns true if the message bytes starts with the specified string."}, {"target_line_num": 559, "target_line_code": "* @param s the string"}, {"target_line_num": 560, "target_line_code": "*/"}, {"target_line_num": 561, "target_line_code": "public boolean startsWithIgnoreCase(String s, int pos) {"}, {"target_line_num": 562, "target_line_code": "char[] c = buff;"}, {"target_line_num": 563, "target_line_code": "int len = s.length();"}, {"target_line_num": 564, "target_line_code": "if (c == null || len+pos > end-start) {"}, {"target_line_num": 565, "target_line_code": "return false;"}, {"target_line_num": 567, "target_line_code": "int off = start+pos;"}, {"target_line_num": 568, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 569, "target_line_code": "if (Ascii.toLower( c[off++] ) != Ascii.toLower( s.charAt(i))) {"}, {"target_line_num": 570, "target_line_code": "return false;"}, {"target_line_num": 573, "target_line_code": "return true;"}, {"target_line_num": 577, "target_line_code": "/**"}, {"target_line_num": 578, "target_line_code": "* Returns true if the message bytes end with the specified string."}, {"target_line_num": 579, "target_line_code": "* @param s the string"}, {"target_line_num": 580, "target_line_code": "*/"}, {"target_line_num": 581, "target_line_code": "public boolean endsWith(String s) {"}, {"target_line_num": 582, "target_line_code": "char[] c = buff;"}, {"target_line_num": 583, "target_line_code": "int len = s.length();"}, {"target_line_num": 584, "target_line_code": "if (c == null || len > end-start) {"}, {"target_line_num": 585, "target_line_code": "return false;"}, {"target_line_num": 587, "target_line_code": "int off = end - len;"}, {"target_line_num": 588, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 589, "target_line_code": "if (c[off++] != s.charAt(i)) {"}, {"target_line_num": 590, "target_line_code": "return false;"}, {"target_line_num": 593, "target_line_code": "return true;"}, {"target_line_num": 598, "target_line_code": "@Override"}, {"target_line_num": 599, "target_line_code": "public int hashCode() {"}, {"target_line_num": 600, "target_line_code": "if (hasHashCode) {"}, {"target_line_num": 601, "target_line_code": "return hashCode;"}, {"target_line_num": 603, "target_line_code": "int code = 0;"}, {"target_line_num": 605, "target_line_code": "code = hash();"}, {"target_line_num": 606, "target_line_code": "hashCode = code;"}, {"target_line_num": 607, "target_line_code": "hasHashCode = true;"}, {"target_line_num": 608, "target_line_code": "return code;"}, {"target_line_num": 612, "target_line_code": "public int hash() {"}, {"target_line_num": 613, "target_line_code": "int code=0;"}, {"target_line_num": 614, "target_line_code": "for (int i = start; i < start + end-start; i++) {"}, {"target_line_num": 615, "target_line_code": "code = code * 37 + buff[i];"}, {"target_line_num": 617, "target_line_code": "return code;"}, {"target_line_num": 620, "target_line_code": "public int indexOf(char c) {"}, {"target_line_num": 621, "target_line_code": "return indexOf( c, start);"}, {"target_line_num": 624, "target_line_code": "/**"}, {"target_line_num": 625, "target_line_code": "* Returns true if the message bytes starts with the specified string."}, {"target_line_num": 626, "target_line_code": "* @param c the character"}, {"target_line_num": 627, "target_line_code": "*/"}, {"target_line_num": 628, "target_line_code": "public int indexOf(char c, int starting) {"}, {"target_line_num": 629, "target_line_code": "int ret = indexOf( buff, start+starting, end, c );"}, {"target_line_num": 630, "target_line_code": "return (ret >= start) ? ret - start : -1;"}, {"target_line_num": 633, "target_line_code": "public static int indexOf( char chars[], int off, int cend, char qq )"}, {"target_line_num": 634, "target_line_code": "{"}, {"target_line_num": 635, "target_line_code": "while( off < cend ) {"}, {"target_line_num": 636, "target_line_code": "char b=chars[off];"}, {"target_line_num": 637, "target_line_code": "if( b==qq ) {"}, {"target_line_num": 638, "target_line_code": "return off;"}, {"target_line_num": 640, "target_line_code": "off++;"}, {"target_line_num": 642, "target_line_code": "return -1;"}, {"target_line_num": 646, "target_line_code": "public int indexOf(String src, int srcOff, int srcLen, int myOff ) {"}, {"target_line_num": 647, "target_line_code": "char first=src.charAt( srcOff );"}, {"target_line_num": 650, "target_line_code": "int srcEnd = srcOff + srcLen;"}, {"target_line_num": 652, "target_line_code": "for( int i=myOff+start; i <= (end - srcLen); i++ ) {"}, {"target_line_num": 653, "target_line_code": "if( buff[i] != first ) {"}, {"target_line_num": 654, "target_line_code": "continue;"}, {"target_line_num": 657, "target_line_code": "int myPos=i+1;"}, {"target_line_num": 658, "target_line_code": "for( int srcPos=srcOff + 1; srcPos< srcEnd;) {"}, {"target_line_num": 659, "target_line_code": "if( buff[myPos++] != src.charAt( srcPos++ )) {"}, {"target_line_num": 660, "target_line_code": "break;"}, {"target_line_num": 662, "target_line_code": "if( srcPos==srcEnd )"}, {"target_line_num": 663, "target_line_code": "{"}, {"target_line_num": 668, "target_line_code": "return -1;"}, {"target_line_num": 672, "target_line_code": "private int min(int a, int b) {"}, {"target_line_num": 673, "target_line_code": "if (a < b) {"}, {"target_line_num": 674, "target_line_code": "return a;"}, {"target_line_num": 676, "target_line_code": "return b;"}, {"target_line_num": 681, "target_line_code": "public char charAt(int index) {"}, {"target_line_num": 682, "target_line_code": "return buff[index + start];"}, {"target_line_num": 685, "target_line_code": "public CharSequence subSequence(int start, int end) {"}, {"target_line_num": 686, "target_line_code": "try {"}, {"target_line_num": 687, "target_line_code": "CharChunk result = (CharChunk) this.clone();"}, {"target_line_num": 688, "target_line_code": "result.setOffset(this.start + start);"}, {"target_line_num": 689, "target_line_code": "result.setEnd(this.start + end);"}, {"target_line_num": 690, "target_line_code": "return result;"}, {"target_line_num": 691, "target_line_code": "} catch (CloneNotSupportedException e) {"}, {"target_line_num": 693, "target_line_code": "return null;"}, {"target_line_num": 697, "target_line_code": "public int length() {"}, {"target_line_num": 698, "target_line_code": "return end - start;"}], "removed_line": [], "filename": "core/src/main/java/org/apache/struts2/util/tomcat/buf/CharChunk.java", "patch_func": "no", "diff_file": "struts_CVE-2016-4003_5421930b49822606792f36653b17d3d95ef106f9.diff", "patch_tag": "STRUTS_2_3_37", "source_tag": "STRUTS_2_3_36"}]