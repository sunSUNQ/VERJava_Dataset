[{"cve_id": "struts", "added_line": [{"target_line_num": 2, "target_line_code": "/*"}, {"target_line_num": 3, "target_line_code": "*  Licensed to the Apache Software Foundation (ASF) under one or more"}, {"target_line_num": 4, "target_line_code": "*  contributor license agreements.  See the NOTICE file distributed with"}, {"target_line_num": 5, "target_line_code": "*  this work for additional information regarding copyright ownership."}, {"target_line_num": 6, "target_line_code": "*  The ASF licenses this file to You under the Apache License, Version 2.0"}, {"target_line_num": 7, "target_line_code": "*  (the \"License\"); you may not use this file except in compliance with"}, {"target_line_num": 8, "target_line_code": "*  the License.  You may obtain a copy of the License at"}, {"target_line_num": 9, "target_line_code": "*"}, {"target_line_num": 11, "target_line_code": "*"}, {"target_line_num": 12, "target_line_code": "*  Unless required by applicable law or agreed to in writing, software"}, {"target_line_num": 13, "target_line_code": "*  distributed under the License is distributed on an \"AS IS\" BASIS,"}, {"target_line_num": 14, "target_line_code": "*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."}, {"target_line_num": 15, "target_line_code": "*  See the License for the specific language governing permissions and"}, {"target_line_num": 16, "target_line_code": "*  limitations under the License."}, {"target_line_num": 17, "target_line_code": "*/"}, {"target_line_num": 18, "target_line_code": "package org.apache.struts2.util.tomcat.buf;"}, {"target_line_num": 20, "target_line_code": "import java.io.IOException;"}, {"target_line_num": 21, "target_line_code": "import java.io.Serializable;"}, {"target_line_num": 22, "target_line_code": "import java.nio.ByteBuffer;"}, {"target_line_num": 23, "target_line_code": "import java.nio.CharBuffer;"}, {"target_line_num": 24, "target_line_code": "import java.nio.charset.Charset;"}, {"target_line_num": 26, "target_line_code": "/*"}, {"target_line_num": 27, "target_line_code": "* In a server it is very important to be able to operate on"}, {"target_line_num": 28, "target_line_code": "* the original byte[] without converting everything to chars."}, {"target_line_num": 29, "target_line_code": "* Some protocols are ASCII only, and some allow different"}, {"target_line_num": 30, "target_line_code": "* non-UNICODE encodings. The encoding is not known beforehand,"}, {"target_line_num": 31, "target_line_code": "* and can even change during the execution of the protocol."}, {"target_line_num": 32, "target_line_code": "* ( for example a multipart message may have parts with different"}, {"target_line_num": 33, "target_line_code": "*  encoding )"}, {"target_line_num": 34, "target_line_code": "*"}, {"target_line_num": 35, "target_line_code": "* For HTTP it is not very clear how the encoding of RequestURI"}, {"target_line_num": 36, "target_line_code": "* and mime values can be determined, but it is a great advantage"}, {"target_line_num": 37, "target_line_code": "* to be able to parse the request without converting to string."}, {"target_line_num": 38, "target_line_code": "*/"}, {"target_line_num": 43, "target_line_code": "/**"}, {"target_line_num": 44, "target_line_code": "* This class is used to represent a chunk of bytes, and"}, {"target_line_num": 45, "target_line_code": "* utilities to manipulate byte[]."}, {"target_line_num": 46, "target_line_code": "*"}, {"target_line_num": 47, "target_line_code": "* The buffer can be modified and used for both input and output."}, {"target_line_num": 48, "target_line_code": "*"}, {"target_line_num": 49, "target_line_code": "* There are 2 modes: The chunk can be associated with a sink - ByteInputChannel"}, {"target_line_num": 50, "target_line_code": "* or ByteOutputChannel, which will be used when the buffer is empty (on input)"}, {"target_line_num": 51, "target_line_code": "* or filled (on output)."}, {"target_line_num": 52, "target_line_code": "* For output, it can also grow. This operating mode is selected by calling"}, {"target_line_num": 53, "target_line_code": "* setLimit() or allocate(initial, limit) with limit != -1."}, {"target_line_num": 54, "target_line_code": "*"}, {"target_line_num": 55, "target_line_code": "* Various search and append method are defined - similar with String and"}, {"target_line_num": 56, "target_line_code": "* StringBuffer, but operating on bytes."}, {"target_line_num": 57, "target_line_code": "*"}, {"target_line_num": 58, "target_line_code": "* This is important because it allows processing the http headers directly on"}, {"target_line_num": 59, "target_line_code": "* the received bytes, without converting to chars and Strings until the strings"}, {"target_line_num": 60, "target_line_code": "* are needed. In addition, the charset is determined later, from headers or"}, {"target_line_num": 61, "target_line_code": "* user code."}, {"target_line_num": 62, "target_line_code": "*"}, {"target_line_num": 63, "target_line_code": "* @author dac@sun.com"}, {"target_line_num": 64, "target_line_code": "* @author James Todd [gonzo@sun.com]"}, {"target_line_num": 65, "target_line_code": "* @author Costin Manolache"}, {"target_line_num": 66, "target_line_code": "* @author Remy Maucherat"}, {"target_line_num": 67, "target_line_code": "*/"}, {"target_line_num": 68, "target_line_code": "public final class ByteChunk implements Cloneable, Serializable {"}, {"target_line_num": 70, "target_line_code": "private static final long serialVersionUID = 1L;"}, {"target_line_num": 72, "target_line_code": "/** Input interface, used when the buffer is empty"}, {"target_line_num": 73, "target_line_code": "*"}, {"target_line_num": 74, "target_line_code": "* Same as java.nio.channel.ReadableByteChannel"}, {"target_line_num": 75, "target_line_code": "*/"}, {"target_line_num": 76, "target_line_code": "public static interface ByteInputChannel {"}, {"target_line_num": 77, "target_line_code": "/**"}, {"target_line_num": 78, "target_line_code": "* Read new bytes ( usually the internal conversion buffer )."}, {"target_line_num": 79, "target_line_code": "* The implementation is allowed to ignore the parameters,"}, {"target_line_num": 80, "target_line_code": "* and mutate the chunk if it wishes to implement its own buffering."}, {"target_line_num": 81, "target_line_code": "*/"}, {"target_line_num": 82, "target_line_code": "public int realReadBytes(byte cbuf[], int off, int len)"}, {"target_line_num": 83, "target_line_code": "throws IOException;"}, {"target_line_num": 86, "target_line_code": "/** Same as java.nio.channel.WrittableByteChannel."}, {"target_line_num": 87, "target_line_code": "*/"}, {"target_line_num": 88, "target_line_code": "public static interface ByteOutputChannel {"}, {"target_line_num": 89, "target_line_code": "/**"}, {"target_line_num": 90, "target_line_code": "* Send the bytes ( usually the internal conversion buffer )."}, {"target_line_num": 91, "target_line_code": "* Expect 8k output if the buffer is full."}, {"target_line_num": 92, "target_line_code": "*/"}, {"target_line_num": 93, "target_line_code": "public void realWriteBytes(byte cbuf[], int off, int len)"}, {"target_line_num": 94, "target_line_code": "throws IOException;"}, {"target_line_num": 99, "target_line_code": "/** Default encoding used to convert to strings. It should be UTF8,"}, {"target_line_num": 100, "target_line_code": "as most standards seem to converge, but the servlet API requires"}, {"target_line_num": 101, "target_line_code": "8859_1, and this object is used mostly for servlets."}, {"target_line_num": 102, "target_line_code": "*/"}, {"target_line_num": 103, "target_line_code": "public static final Charset DEFAULT_CHARSET = B2CConverter.ISO_8859_1;"}, {"target_line_num": 106, "target_line_code": "private byte[] buff;"}, {"target_line_num": 108, "target_line_code": "private int start=0;"}, {"target_line_num": 109, "target_line_code": "private int end;"}, {"target_line_num": 111, "target_line_code": "private Charset charset;"}, {"target_line_num": 116, "target_line_code": "private int limit=-1;"}, {"target_line_num": 118, "target_line_code": "private ByteInputChannel in = null;"}, {"target_line_num": 119, "target_line_code": "private ByteOutputChannel out = null;"}, {"target_line_num": 121, "target_line_code": "private boolean optimizedWrite=true;"}, {"target_line_num": 123, "target_line_code": "/**"}, {"target_line_num": 124, "target_line_code": "* Creates a new, uninitialized ByteChunk object."}, {"target_line_num": 125, "target_line_code": "*/"}, {"target_line_num": 126, "target_line_code": "public ByteChunk() {"}, {"target_line_num": 130, "target_line_code": "public ByteChunk( int initial ) {"}, {"target_line_num": 131, "target_line_code": "allocate( initial, -1 );"}, {"target_line_num": 134, "target_line_code": "/**"}, {"target_line_num": 135, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 136, "target_line_code": "*/"}, {"target_line_num": 137, "target_line_code": "@Deprecated"}, {"target_line_num": 138, "target_line_code": "public ByteChunk getClone() {"}, {"target_line_num": 139, "target_line_code": "try {"}, {"target_line_num": 140, "target_line_code": "return (ByteChunk)this.clone();"}, {"target_line_num": 141, "target_line_code": "} catch( Exception ex) {"}, {"target_line_num": 142, "target_line_code": "return null;"}, {"target_line_num": 146, "target_line_code": "public boolean isNull() {"}, {"target_line_num": 150, "target_line_code": "/**"}, {"target_line_num": 151, "target_line_code": "* Resets the message buff to an uninitialized state."}, {"target_line_num": 152, "target_line_code": "*/"}, {"target_line_num": 153, "target_line_code": "public void recycle() {"}, {"target_line_num": 155, "target_line_code": "charset=null;"}, {"target_line_num": 156, "target_line_code": "start=0;"}, {"target_line_num": 157, "target_line_code": "end=0;"}, {"target_line_num": 158, "target_line_code": "isSet=false;"}, {"target_line_num": 161, "target_line_code": "public void reset() {"}, {"target_line_num": 162, "target_line_code": "buff=null;"}, {"target_line_num": 167, "target_line_code": "public void allocate( int initial, int limit  ) {"}, {"target_line_num": 168, "target_line_code": "if( buff==null || buff.length < initial ) {"}, {"target_line_num": 169, "target_line_code": "buff=new byte[initial];"}, {"target_line_num": 171, "target_line_code": "this.limit=limit;"}, {"target_line_num": 172, "target_line_code": "start=0;"}, {"target_line_num": 173, "target_line_code": "end=0;"}, {"target_line_num": 174, "target_line_code": "isSet=true;"}, {"target_line_num": 177, "target_line_code": "/**"}, {"target_line_num": 178, "target_line_code": "* Sets the message bytes to the specified subarray of bytes."}, {"target_line_num": 179, "target_line_code": "*"}, {"target_line_num": 180, "target_line_code": "* @param b the ascii bytes"}, {"target_line_num": 181, "target_line_code": "* @param off the start offset of the bytes"}, {"target_line_num": 182, "target_line_code": "* @param len the length of the bytes"}, {"target_line_num": 183, "target_line_code": "*/"}, {"target_line_num": 184, "target_line_code": "public void setBytes(byte[] b, int off, int len) {"}, {"target_line_num": 185, "target_line_code": "buff = b;"}, {"target_line_num": 186, "target_line_code": "start = off;"}, {"target_line_num": 187, "target_line_code": "end = start+ len;"}, {"target_line_num": 188, "target_line_code": "isSet=true;"}, {"target_line_num": 191, "target_line_code": "/**"}, {"target_line_num": 192, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 193, "target_line_code": "*/"}, {"target_line_num": 194, "target_line_code": "@Deprecated"}, {"target_line_num": 195, "target_line_code": "public void setOptimizedWrite(boolean optimizedWrite) {"}, {"target_line_num": 196, "target_line_code": "this.optimizedWrite = optimizedWrite;"}, {"target_line_num": 199, "target_line_code": "public void setCharset(Charset charset) {"}, {"target_line_num": 200, "target_line_code": "this.charset = charset;"}, {"target_line_num": 203, "target_line_code": "public Charset getCharset() {"}, {"target_line_num": 204, "target_line_code": "if (charset == null) {"}, {"target_line_num": 205, "target_line_code": "charset = DEFAULT_CHARSET;"}, {"target_line_num": 207, "target_line_code": "return charset;"}, {"target_line_num": 210, "target_line_code": "/**"}, {"target_line_num": 211, "target_line_code": "* Returns the message bytes."}, {"target_line_num": 212, "target_line_code": "*/"}, {"target_line_num": 213, "target_line_code": "public byte[] getBytes() {"}, {"target_line_num": 214, "target_line_code": "return getBuffer();"}, {"target_line_num": 217, "target_line_code": "/**"}, {"target_line_num": 218, "target_line_code": "* Returns the message bytes."}, {"target_line_num": 219, "target_line_code": "*/"}, {"target_line_num": 220, "target_line_code": "public byte[] getBuffer() {"}, {"target_line_num": 221, "target_line_code": "return buff;"}, {"target_line_num": 224, "target_line_code": "/**"}, {"target_line_num": 225, "target_line_code": "* Returns the start offset of the bytes."}, {"target_line_num": 226, "target_line_code": "* For output this is the end of the buffer."}, {"target_line_num": 227, "target_line_code": "*/"}, {"target_line_num": 228, "target_line_code": "public int getStart() {"}, {"target_line_num": 229, "target_line_code": "return start;"}, {"target_line_num": 232, "target_line_code": "public int getOffset() {"}, {"target_line_num": 233, "target_line_code": "return start;"}, {"target_line_num": 236, "target_line_code": "public void setOffset(int off) {"}, {"target_line_num": 237, "target_line_code": "if (end < off ) {"}, {"target_line_num": 238, "target_line_code": "end=off;"}, {"target_line_num": 240, "target_line_code": "start=off;"}, {"target_line_num": 243, "target_line_code": "/**"}, {"target_line_num": 244, "target_line_code": "* Returns the length of the bytes."}, {"target_line_num": 245, "target_line_code": "* XXX need to clean this up"}, {"target_line_num": 246, "target_line_code": "*/"}, {"target_line_num": 247, "target_line_code": "public int getLength() {"}, {"target_line_num": 248, "target_line_code": "return end-start;"}, {"target_line_num": 251, "target_line_code": "/** Maximum amount of data in this buffer."}, {"target_line_num": 252, "target_line_code": "*"}, {"target_line_num": 253, "target_line_code": "*  If -1 or not set, the buffer will grow indefinitely."}, {"target_line_num": 254, "target_line_code": "*  Can be smaller than the current buffer size ( which will not shrink )."}, {"target_line_num": 255, "target_line_code": "*  When the limit is reached, the buffer will be flushed ( if out is set )"}, {"target_line_num": 256, "target_line_code": "*  or throw exception."}, {"target_line_num": 257, "target_line_code": "*/"}, {"target_line_num": 258, "target_line_code": "public void setLimit(int limit) {"}, {"target_line_num": 259, "target_line_code": "this.limit=limit;"}, {"target_line_num": 262, "target_line_code": "public int getLimit() {"}, {"target_line_num": 263, "target_line_code": "return limit;"}, {"target_line_num": 266, "target_line_code": "/**"}, {"target_line_num": 267, "target_line_code": "* When the buffer is empty, read the data from the input channel."}, {"target_line_num": 268, "target_line_code": "*/"}, {"target_line_num": 269, "target_line_code": "public void setByteInputChannel(ByteInputChannel in) {"}, {"target_line_num": 270, "target_line_code": "this.in = in;"}, {"target_line_num": 273, "target_line_code": "/** When the buffer is full, write the data to the output channel."}, {"target_line_num": 274, "target_line_code": "*         Also used when large amount of data is appended."}, {"target_line_num": 275, "target_line_code": "*"}, {"target_line_num": 276, "target_line_code": "*  If not set, the buffer will grow to the limit."}, {"target_line_num": 277, "target_line_code": "*/"}, {"target_line_num": 278, "target_line_code": "public void setByteOutputChannel(ByteOutputChannel out) {"}, {"target_line_num": 279, "target_line_code": "this.out=out;"}, {"target_line_num": 282, "target_line_code": "public int getEnd() {"}, {"target_line_num": 283, "target_line_code": "return end;"}, {"target_line_num": 286, "target_line_code": "public void setEnd( int i ) {"}, {"target_line_num": 287, "target_line_code": "end=i;"}, {"target_line_num": 291, "target_line_code": "/** Append a char, by casting it to byte. This IS NOT intended for unicode."}, {"target_line_num": 292, "target_line_code": "*"}, {"target_line_num": 293, "target_line_code": "* @param c"}, {"target_line_num": 294, "target_line_code": "* @throws IOException"}, {"target_line_num": 295, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 296, "target_line_code": "*/"}, {"target_line_num": 297, "target_line_code": "@Deprecated"}, {"target_line_num": 298, "target_line_code": "public void append( char c )"}, {"target_line_num": 299, "target_line_code": "throws IOException"}, {"target_line_num": 300, "target_line_code": "{"}, {"target_line_num": 301, "target_line_code": "append( (byte)c);"}, {"target_line_num": 304, "target_line_code": "public void append( byte b )"}, {"target_line_num": 305, "target_line_code": "throws IOException"}, {"target_line_num": 306, "target_line_code": "{"}, {"target_line_num": 307, "target_line_code": "makeSpace( 1 );"}, {"target_line_num": 310, "target_line_code": "if( limit >0 && end >= limit ) {"}, {"target_line_num": 311, "target_line_code": "flushBuffer();"}, {"target_line_num": 313, "target_line_code": "buff[end++]=b;"}, {"target_line_num": 316, "target_line_code": "public void append( ByteChunk src )"}, {"target_line_num": 317, "target_line_code": "throws IOException"}, {"target_line_num": 318, "target_line_code": "{"}, {"target_line_num": 319, "target_line_code": "append( src.getBytes(), src.getStart(), src.getLength());"}, {"target_line_num": 322, "target_line_code": "/** Add data to the buffer"}, {"target_line_num": 323, "target_line_code": "*/"}, {"target_line_num": 324, "target_line_code": "public void append( byte src[], int off, int len )"}, {"target_line_num": 325, "target_line_code": "throws IOException"}, {"target_line_num": 326, "target_line_code": "{"}, {"target_line_num": 328, "target_line_code": "makeSpace( len );"}, {"target_line_num": 331, "target_line_code": "if( limit < 0 ) {"}, {"target_line_num": 333, "target_line_code": "System.arraycopy( src, off, buff, end, len );"}, {"target_line_num": 334, "target_line_code": "end+=len;"}, {"target_line_num": 335, "target_line_code": "return;"}, {"target_line_num": 342, "target_line_code": "if ( optimizedWrite && len == limit && end == start && out != null ) {"}, {"target_line_num": 343, "target_line_code": "out.realWriteBytes( src, off, len );"}, {"target_line_num": 344, "target_line_code": "return;"}, {"target_line_num": 347, "target_line_code": "if( len <= limit - end ) {"}, {"target_line_num": 350, "target_line_code": "System.arraycopy( src, off, buff, end, len );"}, {"target_line_num": 351, "target_line_code": "end+=len;"}, {"target_line_num": 352, "target_line_code": "return;"}, {"target_line_num": 363, "target_line_code": "int avail=limit-end;"}, {"target_line_num": 364, "target_line_code": "System.arraycopy(src, off, buff, end, avail);"}, {"target_line_num": 365, "target_line_code": "end += avail;"}, {"target_line_num": 367, "target_line_code": "flushBuffer();"}, {"target_line_num": 369, "target_line_code": "int remain = len - avail;"}, {"target_line_num": 371, "target_line_code": "while (remain > (limit - end)) {"}, {"target_line_num": 372, "target_line_code": "out.realWriteBytes( src, (off + len) - remain, limit - end );"}, {"target_line_num": 373, "target_line_code": "remain = remain - (limit - end);"}, {"target_line_num": 376, "target_line_code": "System.arraycopy(src, (off + len) - remain, buff, end, remain);"}, {"target_line_num": 377, "target_line_code": "end += remain;"}, {"target_line_num": 384, "target_line_code": "public int substract()"}, {"target_line_num": 385, "target_line_code": "throws IOException {"}, {"target_line_num": 387, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 388, "target_line_code": "if (in == null) {"}, {"target_line_num": 389, "target_line_code": "return -1;"}, {"target_line_num": 391, "target_line_code": "int n = in.realReadBytes( buff, 0, buff.length );"}, {"target_line_num": 392, "target_line_code": "if (n < 0) {"}, {"target_line_num": 393, "target_line_code": "return -1;"}, {"target_line_num": 397, "target_line_code": "return (buff[start++] & 0xFF);"}, {"target_line_num": 402, "target_line_code": "/**"}, {"target_line_num": 403, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 404, "target_line_code": "*/"}, {"target_line_num": 405, "target_line_code": "@Deprecated"}, {"target_line_num": 406, "target_line_code": "public int substract(ByteChunk src)"}, {"target_line_num": 407, "target_line_code": "throws IOException {"}, {"target_line_num": 409, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 410, "target_line_code": "if (in == null) {"}, {"target_line_num": 411, "target_line_code": "return -1;"}, {"target_line_num": 413, "target_line_code": "int n = in.realReadBytes( buff, 0, buff.length );"}, {"target_line_num": 414, "target_line_code": "if (n < 0) {"}, {"target_line_num": 415, "target_line_code": "return -1;"}, {"target_line_num": 419, "target_line_code": "int len = getLength();"}, {"target_line_num": 420, "target_line_code": "src.append(buff, start, len);"}, {"target_line_num": 421, "target_line_code": "start = end;"}, {"target_line_num": 422, "target_line_code": "return len;"}, {"target_line_num": 427, "target_line_code": "public byte substractB()"}, {"target_line_num": 428, "target_line_code": "throws IOException {"}, {"target_line_num": 430, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 431, "target_line_code": "if (in == null)"}, {"target_line_num": 432, "target_line_code": "return -1;"}, {"target_line_num": 433, "target_line_code": "int n = in.realReadBytes( buff, 0, buff.length );"}, {"target_line_num": 434, "target_line_code": "if (n < 0)"}, {"target_line_num": 435, "target_line_code": "return -1;"}, {"target_line_num": 438, "target_line_code": "return (buff[start++]);"}, {"target_line_num": 443, "target_line_code": "public int substract( byte src[], int off, int len )"}, {"target_line_num": 444, "target_line_code": "throws IOException {"}, {"target_line_num": 446, "target_line_code": "if ((end - start) == 0) {"}, {"target_line_num": 447, "target_line_code": "if (in == null) {"}, {"target_line_num": 448, "target_line_code": "return -1;"}, {"target_line_num": 450, "target_line_code": "int n = in.realReadBytes( buff, 0, buff.length );"}, {"target_line_num": 451, "target_line_code": "if (n < 0) {"}, {"target_line_num": 452, "target_line_code": "return -1;"}, {"target_line_num": 456, "target_line_code": "int n = len;"}, {"target_line_num": 457, "target_line_code": "if (len > getLength()) {"}, {"target_line_num": 458, "target_line_code": "n = getLength();"}, {"target_line_num": 460, "target_line_code": "System.arraycopy(buff, start, src, off, n);"}, {"target_line_num": 461, "target_line_code": "start += n;"}, {"target_line_num": 462, "target_line_code": "return n;"}, {"target_line_num": 467, "target_line_code": "/**"}, {"target_line_num": 468, "target_line_code": "* Send the buffer to the sink. Called by append() when the limit is"}, {"target_line_num": 469, "target_line_code": "* reached. You can also call it explicitly to force the data to be written."}, {"target_line_num": 470, "target_line_code": "*"}, {"target_line_num": 471, "target_line_code": "* @throws IOException"}, {"target_line_num": 472, "target_line_code": "*/"}, {"target_line_num": 473, "target_line_code": "public void flushBuffer()"}, {"target_line_num": 474, "target_line_code": "throws IOException"}, {"target_line_num": 475, "target_line_code": "{"}, {"target_line_num": 477, "target_line_code": "if( out==null ) {"}, {"target_line_num": 478, "target_line_code": "throw new IOException( \"Buffer overflow, no sink \" + limit + \" \" +"}, {"target_line_num": 479, "target_line_code": "buff.length  );"}, {"target_line_num": 481, "target_line_code": "out.realWriteBytes( buff, start, end-start );"}, {"target_line_num": 482, "target_line_code": "end=start;"}, {"target_line_num": 485, "target_line_code": "/**"}, {"target_line_num": 486, "target_line_code": "* Make space for len chars. If len is small, allocate a reserve space too."}, {"target_line_num": 487, "target_line_code": "* Never grow bigger than limit."}, {"target_line_num": 488, "target_line_code": "*/"}, {"target_line_num": 489, "target_line_code": "public void makeSpace(int count) {"}, {"target_line_num": 490, "target_line_code": "byte[] tmp = null;"}, {"target_line_num": 492, "target_line_code": "int newSize;"}, {"target_line_num": 493, "target_line_code": "int desiredSize=end + count;"}, {"target_line_num": 496, "target_line_code": "if( limit > 0 &&"}, {"target_line_num": 497, "target_line_code": "desiredSize > limit) {"}, {"target_line_num": 498, "target_line_code": "desiredSize=limit;"}, {"target_line_num": 501, "target_line_code": "if( buff==null ) {"}, {"target_line_num": 502, "target_line_code": "if( desiredSize < 256 )"}, {"target_line_num": 503, "target_line_code": "{"}, {"target_line_num": 506, "target_line_code": "buff=new byte[desiredSize];"}, {"target_line_num": 511, "target_line_code": "if( desiredSize <= buff.length ) {"}, {"target_line_num": 512, "target_line_code": "return;"}, {"target_line_num": 515, "target_line_code": "if( desiredSize < 2 * buff.length ) {"}, {"target_line_num": 516, "target_line_code": "newSize= buff.length * 2;"}, {"target_line_num": 517, "target_line_code": "if( limit >0 &&"}, {"target_line_num": 518, "target_line_code": "newSize > limit ) {"}, {"target_line_num": 519, "target_line_code": "newSize=limit;"}, {"target_line_num": 521, "target_line_code": "tmp=new byte[newSize];"}, {"target_line_num": 522, "target_line_code": "} else {"}, {"target_line_num": 523, "target_line_code": "newSize= buff.length * 2 + count ;"}, {"target_line_num": 524, "target_line_code": "if( limit > 0 &&"}, {"target_line_num": 525, "target_line_code": "newSize > limit ) {"}, {"target_line_num": 526, "target_line_code": "newSize=limit;"}, {"target_line_num": 528, "target_line_code": "tmp=new byte[newSize];"}, {"target_line_num": 531, "target_line_code": "System.arraycopy(buff, start, tmp, 0, end-start);"}, {"target_line_num": 532, "target_line_code": "buff = tmp;"}, {"target_line_num": 533, "target_line_code": "tmp = null;"}, {"target_line_num": 534, "target_line_code": "end=end-start;"}, {"target_line_num": 535, "target_line_code": "start=0;"}, {"target_line_num": 540, "target_line_code": "@Override"}, {"target_line_num": 541, "target_line_code": "public String toString() {"}, {"target_line_num": 542, "target_line_code": "if (null == buff) {"}, {"target_line_num": 543, "target_line_code": "return null;"}, {"target_line_num": 544, "target_line_code": "} else if (end-start == 0) {"}, {"target_line_num": 545, "target_line_code": "return \"\";"}, {"target_line_num": 547, "target_line_code": "return StringCache.toString(this);"}, {"target_line_num": 550, "target_line_code": "public String toStringInternal() {"}, {"target_line_num": 551, "target_line_code": "if (charset == null) {"}, {"target_line_num": 552, "target_line_code": "charset = DEFAULT_CHARSET;"}, {"target_line_num": 557, "target_line_code": "CharBuffer cb;"}, {"target_line_num": 558, "target_line_code": "cb = charset.decode(ByteBuffer.wrap(buff, start, end-start));"}, {"target_line_num": 559, "target_line_code": "return new String(cb.array(), cb.arrayOffset(), cb.length());"}, {"target_line_num": 562, "target_line_code": "/**"}, {"target_line_num": 563, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 564, "target_line_code": "*/"}, {"target_line_num": 565, "target_line_code": "@Deprecated"}, {"target_line_num": 566, "target_line_code": "public int getInt()"}, {"target_line_num": 567, "target_line_code": "{"}, {"target_line_num": 568, "target_line_code": "return Ascii.parseInt(buff, start,end-start);"}, {"target_line_num": 571, "target_line_code": "public long getLong() {"}, {"target_line_num": 572, "target_line_code": "return Ascii.parseLong(buff, start,end-start);"}, {"target_line_num": 578, "target_line_code": "/**"}, {"target_line_num": 579, "target_line_code": "* Compares the message bytes to the specified String object."}, {"target_line_num": 580, "target_line_code": "* @param s the String to compare"}, {"target_line_num": 581, "target_line_code": "* @return true if the comparison succeeded, false otherwise"}, {"target_line_num": 582, "target_line_code": "*/"}, {"target_line_num": 583, "target_line_code": "public boolean equals(String s) {"}, {"target_line_num": 587, "target_line_code": "byte[] b = buff;"}, {"target_line_num": 588, "target_line_code": "int blen = end-start;"}, {"target_line_num": 589, "target_line_code": "if (b == null || blen != s.length()) {"}, {"target_line_num": 590, "target_line_code": "return false;"}, {"target_line_num": 592, "target_line_code": "int boff = start;"}, {"target_line_num": 593, "target_line_code": "for (int i = 0; i < blen; i++) {"}, {"target_line_num": 594, "target_line_code": "if (b[boff++] != s.charAt(i)) {"}, {"target_line_num": 595, "target_line_code": "return false;"}, {"target_line_num": 598, "target_line_code": "return true;"}, {"target_line_num": 601, "target_line_code": "/**"}, {"target_line_num": 602, "target_line_code": "* Compares the message bytes to the specified String object."}, {"target_line_num": 603, "target_line_code": "* @param s the String to compare"}, {"target_line_num": 604, "target_line_code": "* @return true if the comparison succeeded, false otherwise"}, {"target_line_num": 605, "target_line_code": "*/"}, {"target_line_num": 606, "target_line_code": "public boolean equalsIgnoreCase(String s) {"}, {"target_line_num": 607, "target_line_code": "byte[] b = buff;"}, {"target_line_num": 608, "target_line_code": "int blen = end-start;"}, {"target_line_num": 609, "target_line_code": "if (b == null || blen != s.length()) {"}, {"target_line_num": 610, "target_line_code": "return false;"}, {"target_line_num": 612, "target_line_code": "int boff = start;"}, {"target_line_num": 613, "target_line_code": "for (int i = 0; i < blen; i++) {"}, {"target_line_num": 614, "target_line_code": "if (Ascii.toLower(b[boff++]) != Ascii.toLower(s.charAt(i))) {"}, {"target_line_num": 615, "target_line_code": "return false;"}, {"target_line_num": 618, "target_line_code": "return true;"}, {"target_line_num": 621, "target_line_code": "public boolean equals( ByteChunk bb ) {"}, {"target_line_num": 622, "target_line_code": "return equals( bb.getBytes(), bb.getStart(), bb.getLength());"}, {"target_line_num": 625, "target_line_code": "public boolean equals( byte b2[], int off2, int len2) {"}, {"target_line_num": 626, "target_line_code": "byte b1[]=buff;"}, {"target_line_num": 627, "target_line_code": "if( b1==null && b2==null ) {"}, {"target_line_num": 628, "target_line_code": "return true;"}, {"target_line_num": 631, "target_line_code": "int len=end-start;"}, {"target_line_num": 632, "target_line_code": "if ( len2 != len || b1==null || b2==null ) {"}, {"target_line_num": 633, "target_line_code": "return false;"}, {"target_line_num": 636, "target_line_code": "int off1 = start;"}, {"target_line_num": 638, "target_line_code": "while ( len-- > 0) {"}, {"target_line_num": 639, "target_line_code": "if (b1[off1++] != b2[off2++]) {"}, {"target_line_num": 640, "target_line_code": "return false;"}, {"target_line_num": 643, "target_line_code": "return true;"}, {"target_line_num": 646, "target_line_code": "public boolean equals( CharChunk cc ) {"}, {"target_line_num": 647, "target_line_code": "return equals( cc.getChars(), cc.getStart(), cc.getLength());"}, {"target_line_num": 650, "target_line_code": "public boolean equals( char c2[], int off2, int len2) {"}, {"target_line_num": 652, "target_line_code": "byte b1[]=buff;"}, {"target_line_num": 653, "target_line_code": "if( c2==null && b1==null ) {"}, {"target_line_num": 654, "target_line_code": "return true;"}, {"target_line_num": 657, "target_line_code": "if (b1== null || c2==null || end-start != len2 ) {"}, {"target_line_num": 658, "target_line_code": "return false;"}, {"target_line_num": 660, "target_line_code": "int off1 = start;"}, {"target_line_num": 661, "target_line_code": "int len=end-start;"}, {"target_line_num": 663, "target_line_code": "while ( len-- > 0) {"}, {"target_line_num": 664, "target_line_code": "if ( (char)b1[off1++] != c2[off2++]) {"}, {"target_line_num": 665, "target_line_code": "return false;"}, {"target_line_num": 668, "target_line_code": "return true;"}, {"target_line_num": 671, "target_line_code": "/**"}, {"target_line_num": 672, "target_line_code": "* Returns true if the message bytes starts with the specified string."}, {"target_line_num": 673, "target_line_code": "* @param s the string"}, {"target_line_num": 674, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 675, "target_line_code": "*/"}, {"target_line_num": 676, "target_line_code": "@Deprecated"}, {"target_line_num": 677, "target_line_code": "public boolean startsWith(String s) {"}, {"target_line_num": 679, "target_line_code": "byte[] b = buff;"}, {"target_line_num": 680, "target_line_code": "int blen = s.length();"}, {"target_line_num": 681, "target_line_code": "if (b == null || blen > end-start) {"}, {"target_line_num": 682, "target_line_code": "return false;"}, {"target_line_num": 684, "target_line_code": "int boff = start;"}, {"target_line_num": 685, "target_line_code": "for (int i = 0; i < blen; i++) {"}, {"target_line_num": 686, "target_line_code": "if (b[boff++] != s.charAt(i)) {"}, {"target_line_num": 687, "target_line_code": "return false;"}, {"target_line_num": 690, "target_line_code": "return true;"}, {"target_line_num": 693, "target_line_code": "/**"}, {"target_line_num": 694, "target_line_code": "* Returns true if the message bytes start with the specified byte array."}, {"target_line_num": 695, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 696, "target_line_code": "*/"}, {"target_line_num": 697, "target_line_code": "@Deprecated"}, {"target_line_num": 698, "target_line_code": "public boolean startsWith(byte[] b2) {"}, {"target_line_num": 699, "target_line_code": "byte[] b1 = buff;"}, {"target_line_num": 700, "target_line_code": "if (b1 == null && b2 == null) {"}, {"target_line_num": 701, "target_line_code": "return true;"}, {"target_line_num": 704, "target_line_code": "int len = end - start;"}, {"target_line_num": 705, "target_line_code": "if (b1 == null || b2 == null || b2.length > len) {"}, {"target_line_num": 706, "target_line_code": "return false;"}, {"target_line_num": 708, "target_line_code": "for (int i = start, j = 0; i < end && j < b2.length;) {"}, {"target_line_num": 709, "target_line_code": "if (b1[i++] != b2[j++]) {"}, {"target_line_num": 710, "target_line_code": "return false;"}, {"target_line_num": 713, "target_line_code": "return true;"}, {"target_line_num": 716, "target_line_code": "/**"}, {"target_line_num": 717, "target_line_code": "* Returns true if the message bytes starts with the specified string."}, {"target_line_num": 718, "target_line_code": "* @param s the string"}, {"target_line_num": 719, "target_line_code": "* @param pos The position"}, {"target_line_num": 720, "target_line_code": "*/"}, {"target_line_num": 721, "target_line_code": "public boolean startsWithIgnoreCase(String s, int pos) {"}, {"target_line_num": 722, "target_line_code": "byte[] b = buff;"}, {"target_line_num": 723, "target_line_code": "int len = s.length();"}, {"target_line_num": 724, "target_line_code": "if (b == null || len+pos > end-start) {"}, {"target_line_num": 725, "target_line_code": "return false;"}, {"target_line_num": 727, "target_line_code": "int off = start+pos;"}, {"target_line_num": 728, "target_line_code": "for (int i = 0; i < len; i++) {"}, {"target_line_num": 729, "target_line_code": "if (Ascii.toLower( b[off++] ) != Ascii.toLower( s.charAt(i))) {"}, {"target_line_num": 730, "target_line_code": "return false;"}, {"target_line_num": 733, "target_line_code": "return true;"}, {"target_line_num": 736, "target_line_code": "public int indexOf( String src, int srcOff, int srcLen, int myOff ) {"}, {"target_line_num": 737, "target_line_code": "char first=src.charAt( srcOff );"}, {"target_line_num": 740, "target_line_code": "int srcEnd = srcOff + srcLen;"}, {"target_line_num": 742, "target_line_code": "mainLoop:"}, {"target_line_num": 743, "target_line_code": "for( int i=myOff+start; i <= (end - srcLen); i++ ) {"}, {"target_line_num": 744, "target_line_code": "if( buff[i] != first ) {"}, {"target_line_num": 745, "target_line_code": "continue;"}, {"target_line_num": 748, "target_line_code": "int myPos=i+1;"}, {"target_line_num": 749, "target_line_code": "for( int srcPos=srcOff + 1; srcPos< srcEnd;) {"}, {"target_line_num": 750, "target_line_code": "if( buff[myPos++] != src.charAt( srcPos++ )) {"}, {"target_line_num": 751, "target_line_code": "continue mainLoop;"}, {"target_line_num": 756, "target_line_code": "return -1;"}, {"target_line_num": 762, "target_line_code": "public int hash() {"}, {"target_line_num": 763, "target_line_code": "return hashBytes( buff, start, end-start);"}, {"target_line_num": 766, "target_line_code": "/**"}, {"target_line_num": 767, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 768, "target_line_code": "*/"}, {"target_line_num": 769, "target_line_code": "@Deprecated"}, {"target_line_num": 770, "target_line_code": "public int hashIgnoreCase() {"}, {"target_line_num": 771, "target_line_code": "return hashBytesIC( buff, start, end-start );"}, {"target_line_num": 774, "target_line_code": "private static int hashBytes( byte buff[], int start, int bytesLen ) {"}, {"target_line_num": 775, "target_line_code": "int max=start+bytesLen;"}, {"target_line_num": 776, "target_line_code": "byte bb[]=buff;"}, {"target_line_num": 777, "target_line_code": "int code=0;"}, {"target_line_num": 778, "target_line_code": "for (int i = start; i < max ; i++) {"}, {"target_line_num": 779, "target_line_code": "code = code * 37 + bb[i];"}, {"target_line_num": 781, "target_line_code": "return code;"}, {"target_line_num": 784, "target_line_code": "private static int hashBytesIC( byte bytes[], int start,"}, {"target_line_num": 785, "target_line_code": "int bytesLen )"}, {"target_line_num": 786, "target_line_code": "{"}, {"target_line_num": 787, "target_line_code": "int max=start+bytesLen;"}, {"target_line_num": 788, "target_line_code": "byte bb[]=bytes;"}, {"target_line_num": 789, "target_line_code": "int code=0;"}, {"target_line_num": 790, "target_line_code": "for (int i = start; i < max ; i++) {"}, {"target_line_num": 791, "target_line_code": "code = code * 37 + Ascii.toLower(bb[i]);"}, {"target_line_num": 793, "target_line_code": "return code;"}, {"target_line_num": 796, "target_line_code": "/**"}, {"target_line_num": 797, "target_line_code": "* Returns the first instance of the given character in this ByteChunk"}, {"target_line_num": 798, "target_line_code": "* starting at the specified byte. If the character is not found, -1 is"}, {"target_line_num": 799, "target_line_code": "* returned."}, {"target_line_num": 800, "target_line_code": "* <br/>"}, {"target_line_num": 801, "target_line_code": "* NOTE: This only works for characters in the range 0-127."}, {"target_line_num": 802, "target_line_code": "*"}, {"target_line_num": 803, "target_line_code": "* @param c         The character"}, {"target_line_num": 804, "target_line_code": "* @param starting  The start position"}, {"target_line_num": 805, "target_line_code": "* @return          The position of the first instance of the character or"}, {"target_line_num": 806, "target_line_code": "*                      -1 if the character is not found."}, {"target_line_num": 807, "target_line_code": "*/"}, {"target_line_num": 808, "target_line_code": "public int indexOf(char c, int starting) {"}, {"target_line_num": 809, "target_line_code": "int ret = indexOf(buff, start + starting, end, c);"}, {"target_line_num": 810, "target_line_code": "return (ret >= start) ? ret - start : -1;"}, {"target_line_num": 813, "target_line_code": "/**"}, {"target_line_num": 814, "target_line_code": "* Returns the first instance of the given character in the given byte array"}, {"target_line_num": 815, "target_line_code": "* between the specified start and end."}, {"target_line_num": 816, "target_line_code": "* <br/>"}, {"target_line_num": 817, "target_line_code": "* NOTE: This only works for characters in the range 0-127."}, {"target_line_num": 818, "target_line_code": "*"}, {"target_line_num": 819, "target_line_code": "* @param bytes The byte array to search"}, {"target_line_num": 820, "target_line_code": "* @param start The point to start searching from in the byte array"}, {"target_line_num": 821, "target_line_code": "* @param end   The point to stop searching in the byte array"}, {"target_line_num": 822, "target_line_code": "* @param c     The character to search for"}, {"target_line_num": 823, "target_line_code": "* @return      The position of the first instance of the character or -1"}, {"target_line_num": 824, "target_line_code": "*                  if the character is not found."}, {"target_line_num": 825, "target_line_code": "*/"}, {"target_line_num": 826, "target_line_code": "public static int indexOf(byte bytes[], int start, int end, char c) {"}, {"target_line_num": 827, "target_line_code": "int offset = start;"}, {"target_line_num": 829, "target_line_code": "while (offset < end) {"}, {"target_line_num": 830, "target_line_code": "byte b=bytes[offset];"}, {"target_line_num": 831, "target_line_code": "if (b == c) {"}, {"target_line_num": 832, "target_line_code": "return offset;"}, {"target_line_num": 834, "target_line_code": "offset++;"}, {"target_line_num": 836, "target_line_code": "return -1;"}, {"target_line_num": 839, "target_line_code": "/**"}, {"target_line_num": 840, "target_line_code": "* Returns the first instance of the given byte in the byte array between"}, {"target_line_num": 841, "target_line_code": "* the specified start and end."}, {"target_line_num": 842, "target_line_code": "*"}, {"target_line_num": 843, "target_line_code": "* @param bytes The byte array to search"}, {"target_line_num": 844, "target_line_code": "* @param start The point to start searching from in the byte array"}, {"target_line_num": 845, "target_line_code": "* @param end   The point to stop searching in the byte array"}, {"target_line_num": 846, "target_line_code": "* @param b     The byte to search for"}, {"target_line_num": 847, "target_line_code": "* @return      The position of the first instance of the byte or -1 if the"}, {"target_line_num": 848, "target_line_code": "*                  byte is not found."}, {"target_line_num": 849, "target_line_code": "*/"}, {"target_line_num": 850, "target_line_code": "public static int findByte(byte bytes[], int start, int end, byte b) {"}, {"target_line_num": 851, "target_line_code": "int offset = start;"}, {"target_line_num": 852, "target_line_code": "while (offset < end) {"}, {"target_line_num": 853, "target_line_code": "if (bytes[offset] == b) {"}, {"target_line_num": 854, "target_line_code": "return offset;"}, {"target_line_num": 856, "target_line_code": "offset++;"}, {"target_line_num": 858, "target_line_code": "return -1;"}, {"target_line_num": 861, "target_line_code": "/**"}, {"target_line_num": 862, "target_line_code": "* Returns the first instance of any of the given bytes in the byte array"}, {"target_line_num": 863, "target_line_code": "* between the specified start and end."}, {"target_line_num": 864, "target_line_code": "*"}, {"target_line_num": 865, "target_line_code": "* @param bytes The byte array to search"}, {"target_line_num": 866, "target_line_code": "* @param start The point to start searching from in the byte array"}, {"target_line_num": 867, "target_line_code": "* @param end   The point to stop searching in the byte array"}, {"target_line_num": 868, "target_line_code": "* @param b     The array of bytes to search for"}, {"target_line_num": 869, "target_line_code": "* @return      The position of the first instance of the byte or -1 if the"}, {"target_line_num": 870, "target_line_code": "*                  byte is not found."}, {"target_line_num": 871, "target_line_code": "*/"}, {"target_line_num": 872, "target_line_code": "public static int findBytes(byte bytes[], int start, int end, byte b[]) {"}, {"target_line_num": 873, "target_line_code": "int blen = b.length;"}, {"target_line_num": 874, "target_line_code": "int offset = start;"}, {"target_line_num": 875, "target_line_code": "while (offset < end) {"}, {"target_line_num": 876, "target_line_code": "for (int i = 0;  i < blen; i++) {"}, {"target_line_num": 877, "target_line_code": "if (bytes[offset] == b[i]) {"}, {"target_line_num": 878, "target_line_code": "return offset;"}, {"target_line_num": 881, "target_line_code": "offset++;"}, {"target_line_num": 883, "target_line_code": "return -1;"}, {"target_line_num": 886, "target_line_code": "/**"}, {"target_line_num": 887, "target_line_code": "* Returns the first instance of any byte that is not one of the given bytes"}, {"target_line_num": 888, "target_line_code": "* in the byte array between the specified start and end."}, {"target_line_num": 889, "target_line_code": "*"}, {"target_line_num": 890, "target_line_code": "* @param bytes The byte array to search"}, {"target_line_num": 891, "target_line_code": "* @param start The point to start searching from in the byte array"}, {"target_line_num": 892, "target_line_code": "* @param end   The point to stop searching in the byte array"}, {"target_line_num": 893, "target_line_code": "* @param b     The list of bytes to search for"}, {"target_line_num": 894, "target_line_code": "* @return      The position of the first instance a byte that is not"}, {"target_line_num": 895, "target_line_code": "*                  in the list of bytes to search for or -1 if no such byte"}, {"target_line_num": 896, "target_line_code": "*                  is found."}, {"target_line_num": 897, "target_line_code": "* @deprecated Unused. Will be removed in Tomcat 8.0.x onwards."}, {"target_line_num": 898, "target_line_code": "*/"}, {"target_line_num": 899, "target_line_code": "@Deprecated"}, {"target_line_num": 900, "target_line_code": "public static int findNotBytes(byte bytes[], int start, int end, byte b[]) {"}, {"target_line_num": 901, "target_line_code": "int blen = b.length;"}, {"target_line_num": 902, "target_line_code": "int offset = start;"}, {"target_line_num": 903, "target_line_code": "boolean found;"}, {"target_line_num": 905, "target_line_code": "while (offset < end) {"}, {"target_line_num": 906, "target_line_code": "found = true;"}, {"target_line_num": 907, "target_line_code": "for (int i = 0; i < blen; i++) {"}, {"target_line_num": 908, "target_line_code": "if (bytes[offset] == b[i]) {"}, {"target_line_num": 909, "target_line_code": "found=false;"}, {"target_line_num": 910, "target_line_code": "break;"}, {"target_line_num": 913, "target_line_code": "if (found) {"}, {"target_line_num": 914, "target_line_code": "return offset;"}, {"target_line_num": 916, "target_line_code": "offset++;"}, {"target_line_num": 918, "target_line_code": "return -1;"}, {"target_line_num": 922, "target_line_code": "/**"}, {"target_line_num": 923, "target_line_code": "* Convert specified String to a byte array. This ONLY WORKS for ascii, UTF"}, {"target_line_num": 924, "target_line_code": "* chars will be truncated."}, {"target_line_num": 925, "target_line_code": "*"}, {"target_line_num": 926, "target_line_code": "* @param value to convert to byte array"}, {"target_line_num": 927, "target_line_code": "* @return the byte array value"}, {"target_line_num": 928, "target_line_code": "*/"}, {"target_line_num": 929, "target_line_code": "public static final byte[] convertToBytes(String value) {"}, {"target_line_num": 930, "target_line_code": "byte[] result = new byte[value.length()];"}, {"target_line_num": 931, "target_line_code": "for (int i = 0; i < value.length(); i++) {"}, {"target_line_num": 932, "target_line_code": "result[i] = (byte) value.charAt(i);"}, {"target_line_num": 934, "target_line_code": "return result;"}], "removed_line": [], "filename": "core/src/main/java/org/apache/struts2/util/tomcat/buf/ByteChunk.java", "patch_func": "no", "diff_file": "struts_CVE-2016-4003_76f188406eb9f17a06afcb5f49f0c44d749da0d2.diff", "patch_tag": "STRUTS_6_0_0_RC1", "source_tag": "STRUTS_2_5_BETA3"}]